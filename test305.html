<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      You are given an array X of floating-point numbers x1, x2, ... xn. These
      can be rounded up or down to create a corresponding array Y of integers
      y1, y2, ... yn. Write an algorithm that finds an appropriate Y array with
      the following properties: The rounded sums of both arrays should be equal.
      The absolute pairwise difference between elements is minimized. In other
      words, |x1- y1| + |x2- y2| + ... + |xn- yn| should be as small as
      possible.
    </title>
  </head>
  <body>
    <script>
      function roundWithMinError(X) {
        const n = X.length;

        // Step 1 & 2: floor values and fractional parts
        const items = X.map((x, i) => ({
          index: i,
          floor: Math.floor(x),
          frac: x - Math.floor(x),
        }));

        // Step 3: target rounded sum
        const targetSum = Math.round(X.reduce((a, b) => a + b, 0));

        // Step 4: current sum of floors
        let currentSum = items.reduce((sum, item) => sum + item.floor, 0);

        // Step 5: how many values need to be rounded up
        let k = targetSum - currentSum;

        // Step 6: sort by fractional part descending
        items.sort((a, b) => b.frac - a.frac);

        // Step 7: add 1 to the largest fractions
        const Y = new Array(n);
        for (let i = 0; i < n; i++) {
          Y[items[i].index] = items[i].floor + (i < k ? 1 : 0);
        }

        return Y;
      }
      const X = [1.3, 2.3, 4.4];
      console.log(roundWithMinError(X));
    </script>
  </body>
</html>
